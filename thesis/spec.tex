\chapter{Formal Specification}\label{sec:spec}

As we are heading towards implementation considerations in~\cref{sec:impl}, we provide a formal specification of the usage analysis in this section.

Despite being massively more simple than Haskells surface syntax, GHC Core still captures many details inessential to the analysis. In order to keep the mathematical formulation as concise as possible, we define the transfer function in terms of a simplified object language.

\section{Object Language}\label{sec:exp}

\begin{figure}
\begin{alignat*}{2}
x,y,z,\sMkPair &\in \sVar \\
e &\in \sExp & {}\Coloneqq{}                    & x \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sPair{x_1}{x_2} \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sLam{x}{e} \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sApp{e}{x} \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sCase{e_s}{x_1}{x_2}{e_r} \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sLet{\bind}{e} \\
  &          & \mathwithin{{}\Coloneqq{}}{\mid} & \sLetRec{\binds}{e} \\
\end{alignat*}
\caption{A simple untyped lambda calculus}
\label{fig:exp}
\end{figure}

The formalization of the usage analysis operates on a simple untyped lambda calculus, described in \cref{fig:exp}. The only extensions are pair constructors, complemented with \keyword{case} expressions to destruct them, and possibly recursive \keyword{let} bindings. 
We draw variable names from an abstract set $\sVar$. Of particular note is the identifier $\sMkPair$, which always refers to the pair constructor as a function of two arguments and may not be rebound by a \keyword{let} expression. 
As is customary in both \textcite{card} and \textcite{callarity}, we assume administrative normal form \parencite{sabry92}, so that arguments to applications can only mention identifiers. Applications to non-trivial arguments like $\sApp{e_1}{e_2}$ must be rewritten as $\sLet{x_2 = e_2}{\sApp{e_1}{x_2}}$, hence issues concerning sharing only surface while handling \keyword{let}-expressions. Any example in this chapter should assumed to be rewritten according to this rule.

\section{Expression Use, Identifier Usage and Usage Signatures}

A usage analysis approximates how a use of an expression translates into a use of its subexpressions. Important analysis information includes \parencite{card}:

\begin{enumerate}
\item How many times is the body of a lambda expression evaluated, with respect to its defining scope?
\item How many times is a particular thunk evaluated, with respect to its defining scope?
\item Which components of a syntactic expression are never used, that is, absent?
\end{enumerate}

GHC's Demand Analyzer integrates a usage analysis that answers these questions by the name of \emph{higher-order cardinality analysis} \parencite{card}. 
Our analysis builds on this approach in that the central lattices have been borrowed unchanged, but have been enriched and distinguished with further semantic meaning.

\begin{figure}
\begin{alignat*}{2}
u   &\in \sUse   &{} \Coloneqq {}& HU \mid U \mid C^n(u) \mid U(u^*_1, u^*_2) \\
u^* &\in \sUsage &{} \Coloneqq {}& A \mid n*u \\
n   &\in \sMulti &{} \Coloneqq {}& 1 \mid \omega
\end{alignat*}
\begin{alignat*}{1}
U(A,A)               &\equiv HU \\
U(\omega*U,\omega*U) &\equiv U \\
C^\omega(U)          &\equiv U
\end{alignat*}
\caption{Syntax of expression $\sUse$ and identifier $\sUsage$ with non-syntactic equalities.}
\label{fig:usg}
\end{figure}

\todo{lattice ops}

\Cref{fig:usg} depicts the $\sUse$ and the $\sUsage$ lattice. 
Typical for a sharing analysis, $\sMulti$ captures usage multiplicity, of which the only interesting values in our setting are \emph{at most once} ($1$) or \emph{possibly multiple times} ($\omega$).

Semantically, a $\sUse$ describes how the value of an expression is used, after evaluating it to weak head normal form (WHNF) \emph{exactly once}.

\begin{itemize}
\item $U(u^*_1, u^*_2)$ captures the $\sUsage$ of pair components (which we will explain shortly) when the expression evaluates to a pair.
\item $C^n(u)$ suggests that the expression evaluates to a lambda expression. 
      Additionally, the resulting value was called at most $n$ times \emph{relative to the single reduction to WHNF} and the use on the result of each call was not worse than $u$.
\item If the value of an expression wasn't used beyond reduction to WHNF, we can attest the expression a head-use $HU$, the bottom of the lattice. 
      Through the first non-syntactic equality in \cref{fig:usg}, $HU$ is identical to a pair use of $U(A,A)$. 
      This arises naturally when, beyond reduction to the pair constructor, no components of the value were used.
      Other than that, $HU$ can only be unleashed on the first argument of a call to the binary primitive \hsinl{seq}.
      Since \hsinl{seq} can be applied to arguments of any type, expressions of function type can also be head-used.
      When a function expression is in head-use, evaluation will stop immediately after uncovering the outer lambda, the body will not be used.
      This corresponds to a hypothetical ill-typed use $C^0(\uscore)$, meaning the lambda is called 0 times relative to the single reduction of the function expression to WHNF.
\item The most conservative analysis result would be the top of the lattice $U$, representing an unknown use beyond reduction to WHNF.
      Where this differs from head-use is best understood in terms of the attached equalities in \cref{fig:usg}.
      For an expression that evaluates to a pair, unknown use would correspond to the pair use $U(\omega*U,\omega*U)$, e.g.\ the pair components have the worst possible usage.
      A unknown use on a function expression can be interpreted as a use of $C^\omega(U)$ by the last equality. 
      By our reasoning above, $C^\omega(U)$ is a call use where the reduced lambda expression is called possibly more than once relative to its single reduction to WHNF and where the result of the call is used according to $U$.
\end{itemize}

The syntax for call uses $C^n(u)$ allows to model \emph{multiple} calls of a function expression relative to a \emph{single} reduction to WHNF. 
Yet it is still unclear how expressions can be used in such a way. 
We would need to \emph{share} the work done by reducing the a function expression to WHNF, so that we can call the resulting value at least twice.
Such sharing can be introduced by binding an expression to an identifier. 
By referring to the bound expression through the identifier, we can call the same expression multiple times, while the reduction of the bound expression to WHNF only happens (at most) once. 
Generally, there are various ways to bind an expression to an identifier. 
However, our simple object language was carefully crafted so that sharing is always introduced through \keyword{let}-bindings. 
Other binding mechanisms like lambdas and \keyword{case} just alias another binding. 

It is inappropriate to model usage of an identifier with $\sUse$, as identifiers can syntactically occur more than once, or even be absent. 
Yet every use site, or \emph{usage}, unleashes a $\sUse$ on the identifier's bound expression. 
Thus, every identifier has an associated $\sUsage$, that describes how often and how, if at all, the identifier was used.

\begin{itemize}
\item An identifier $\sUsage$ of $A$ represents \emph{absence} of any usage. Right-hand sides of absent bindings are dead code and never used.
\item A $\sUsage$ of $n*u$ represents that the associated identifier was used at most $n$ times, putting its bound expression under combined use $u$.
\end{itemize}

A few examples are instructive in understanding the definitions so far.

\begin{example} 
Consider the following Haskell expression:

\begin{haskellcode}
let a = f 0 
in let b = f 1 
   in case (a, b) of
        (x, y) -> y
\end{haskellcode}

If we put the expression under some use $U$, we find out the following facts by backtracing evaluation:

\begin{itemize}
\item The case binder \hsinl{y} has usage $1*U$, \hsinl{x} is absent ($A$).
\item The usage on case binders translate to a pair use on \hsinl{(a,b)} of $U(A,1*U)$.
\item The pair constructor forwards its component usages to identifier usages for \hsinl{a} ($A$) and \hsinl{b} ($1*U$).
\item Since we recorded a usage of $1*U$ for \hsinl{b}, we put the right-hand side of the binding under use $U$. 
      One call to a single argument results in a usage of $1*C^1(U)$ on \hsinl{f}.
\item We recognize that the binding for \hsinl{a} is dead, so we don't need to look at its right-hand side at all.
\end{itemize}
\end{example}

In a lazy language with \hsinl{seq} it makes sense to distinguish \emph{use} from \emph{demand} \parencite[Appendix~C.2]{warnsbrough} resp. \emph{call} from \emph{evaluation} \parencite[Section~2.5]{card}, we introduce $\sUsage$ of an identifier.


\todo{mention \textcite{card}'s reasoning for \hsinl{seq} and (multi-)demands}

\todo{mention \textcite{wansbrough}'s glossary and how we define our own}

\textbf{Usage signatures}

\[
\sigma \in \sSig ::= \bot \mid \top \mid u^* \to \sigma
\]

\textbf{Equalities}

\begin{alignat*}{1}
\omega*U \to \top &\equiv \top \\
A \to \bot &\equiv \bot
\end{alignat*}

\textbf{Free-variable graph}

\[
\gamma \in \sGraph = \mathcal{P}(\sVar \times \sVar)
\]

\textbf{Free-variable use environment}

\[
\varphi \in \sUseEnv = \sVar \pfun \sUse
\]

\textbf{Usage types and lookup of free-variable usage}

\[
\theta \in \sUType \Coloneqq \lTriple{\gamma}{\varphi}{\sigma}
\]

\[
\lTriple{\gamma}{\varphi}{\uscore}(x) =
  \begin{cases}
    A, & \text{when } x\notin \dom\varphi \\
    1*\varphi(x), & \text{when } \edge{x}{x} \notin \gamma \\
    \omega*\varphi(x), & \text{otherwise}
  \end{cases}
\]

\begin{alignat*}{1}
&\zap~{}\colon\sUType \to \sUType \\
&\zap~\lTriple{\uscore}{\uscore}{\sigma} = \lTriple{\emptyset}{\emptymap}{\sigma}
\end{alignat*}

\textbf{Usage transformers}

\[
\tau \in \sUTrans = \sUse \to \sUType
\]

\[
\tau^1_x~u = \lTriple{\emptyset}{\maplit{x}{u}}{\top}
\]

\[
\tau_{\sMkPair}~u =
  \begin{cases}
    \lTriple{\emptyset}{\emptymap}{\bot}, & \text{when } u \lless C^1(C^1(\uscore)) \\
    \lTriple{\emptyset}{\emptymap}{u^*_1 \to u^*_2 \to \top}, & \text{when } u = C^1(C^1(U(u^*_1,u^*_2))) \\
    \lTriple{\emptyset}{\emptymap}{\top}, & \text{otherwise}
  \end{cases}
\]

\textbf{Free-variable transformer environment}

\[
\rho \in \sTransEnv = \sVar \pfun \sUTrans
\]


\textbf{Transfer function}

\begin{alignat*}{2}
&\letup{\uscore[\tau]}{\uscore[x]} &\mathmakesamewidth[c]{=}{\colon} &\sUTrans \to \sVar \to \sUTrans \\
&\letup{\tau}{x} &=&
  \begin{cases}
    \tau, & \text{when } \alpha_x = 0 \\
    \zap\circ\tau, & \text{otherwise}
  \end{cases}
\end{alignat*}

\begin{alignat*}{2}
&\letdown{\uscore[\tau]}{\uscore[x]} &\mathmakesamewidth[c]{=}{\colon} &\sUTrans \to \sVar \to \sUTrans \\
&\letdown{\tau}{x} &=&
  \begin{cases}
    \tau, & \text{when } \alpha_x = 0 \\
    \tau, & \text{otherwise}
  \end{cases}
\end{alignat*}

\begin{alignat*}{2}
&\liftstar{\uscore[\tau]}~A &{}={}& \lTriple{\emptyset}{\emptymap}{\bot} \\
&\liftstar{\tau}~(n*u)      &{}={}& n*(\tau~u)
\end{alignat*}

\begin{alignat*}{2}
&\liftqm{\uscore[\tau]}~A     &{}={}& \lTriple{\emptyset}{\emptymap}{\bot} \\
&\liftqm{\tau}~(\uscore[n]*u) &{}={}& \tau~u
\end{alignat*}

\begin{alignat*}{2}
&\transfer{\uscore[x]}{\uscore}&\mathmakesamewidth[c]{{}={}}{\colon} &\sExp \to \sTransEnv \to \sUTrans \\
&\transfer{x}{\rho} &{}={}&
  \begin{cases}
    \tau_{\sMkPair}, & \text{when } x = \sMkPair \\
    \rho(x) \both \tau^1_x, & \text{when } x\in \dom{\rho} \\
    \tau^1_x, & \text{otherwise}
  \end{cases} \\
&\transfer{\sLam{x}{e}}{\rho}\,u &{}={}&
  \begin{cases}
    \lTriple{\emptyset}{\emptymap}{\bot}, & \text{when } u = HU \\
    n*\lTriple{\gamma\setminus_x}{\varphi\setminus_x}{\theta(x) \to \sigma}, & \text{where } u = C^n(u_b),~\lTriple{\gamma}{\varphi}{\sigma} = \theta = \transfer{e}{\rho}\,u_b
  \end{cases} \\
&\transfer{\sPair{x_1}{x_2}}{\rho} &{}={}& \transfer{\sApp{\sApp{\sMkPair}{x_1}}{x_2}}{\rho} \\
&\transfer{\sApp{e}{x}}{\rho}\,u &{}={}& \lTriple{\gamma_e}{\varphi_e}{\sigma} \both \theta_x \\
   &&&\text{where }
     \lTriple{\gamma_e}{\varphi_e}{u^* \to \sigma} = \transfer{e}{\rho}\,C^1(u),~
     \theta_x = \liftstar{\transfer{x}{\rho}}\,u^* \\
&\transfer{\sCase{e_s}{x}{y}{e_r}}{\rho}\,u &{}={}& \theta_r\setminus_{x,y} \both \theta_s \\
   &&&\text{where }
     \theta_r = \transfer{e_r}{\rho}\,u,~
     \theta_s = \transfer{e_s}{\rho}\,U(\theta_r(x),\theta_r(y)) \\
&\transfer{\sLet{\bind}{e}}{\rho}\,u &{}={}& \cmblet{\theta}{\maplit{x_1}{\theta_1}} \\
   &&&\text{where }
     \tau_1 = \transfer{e_1}{\rho},~
     \rho' = \maplit{x_1}{\letdown{\tau_1}{x_1}}\rho,~
     \theta = \transfer{e}{\rho'},~
     \theta_1 = \liftqm{\letup{transfer{e_1}{\rho}}{x_1}}{\theta(x_1)} \\
&\transfer{\sLet{\binds}{e}}{\rho}\,u &{}={}& \cmblet{\theta}{\maplit[\overline]{x_i}{\theta_i}} \\
   &&&\text{where }
     \overline{\tau_i = \transfer{e_i}{\rho'}},~
     \rho' = \maplit[\overline]{x_i}{\letdown{\tau_i}{x_i}}\rho,~
     \theta = \transfer{e}{\rho}\,u \llub \transfer{\sLet{\binds}{e}}{\rho}\,u,~
     \overline{\theta_i = \liftqm{\letup{\transfer{e_i}{\rho'}}{x_i}}\,(\theta(x_i) \both \theta(x_i))}
\end{alignat*}
