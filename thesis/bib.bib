@inproceedings{updabs,
abstract = {A requirement of lazy evaluation is that the value of any subexpression in the program is calculated no more than once. This is achieved by updating an expression with its value, once computed. The problem is that updating is a costly operation, and experimentation has shown that it is only necessary in about 30{\%} of cases (that is, 70{\%} of expressions represent values that are only ever required once during execution). The aim of the analysis presented in this paper is to discover expressions that do not need to be updated, and thus reduce the execution time of the program. The analysis has been implemented in the Glasgow Haskell Compiler, and results are given.},
address = {Ayr, Scotland},
author = {Marlow, Simon},
booktitle = {Proceedings of the 1993 Glasgow Workshop on Functional Programming},
publisher = {Springer-Verlag},
series = {Workshops in Computing},
title = {{Update Avoidance Analysis by Abstract Interpretation}},
year = {1993}
}
@article{Launchbury1994,
abstract = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating stateful computations that manipulate multiple, named, mutable objects, in the context of a non-strict, purely-functional language. The security of the encapsulation is assured by the type system, using parametricity. Intriguingly, this parametricity requires the provision of a (single) constant with a rank-2 polymorphic type.},
author = {Launchbury, John and {Peyton Jones}, Simon L.},
doi = {10.1145/773473.178246},
isbn = {089791662X},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {statethreads},
pages = {24--35},
title = {{Lazy functional state threads}},
volume = {29},
year = {1994}
}
@article{pippenger,
abstract = {[PDF]},
author = {Pippenger, Nicholas},
doi = {10.1145/244795.244798},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
number = {2},
pages = {223--238},
title = {{Pure versus impure Lisp}},
volume = {19},
year = {1997}
}
@article{bird,
author = {Bird, Richard S and Jones, Geraint and de Moor, Oege},
journal = {J. Funct. Program.},
pages = {541--547},
title = {{More Haste, Less Speed: Lazy Versus Eager Evaluation}},
volume = {7},
year = {1997}
}
@article{nofib,
author = {Partain, Will and Others},
isbn = {3-540-19820-2},
journal = {Proceedings of the 1992 Glasgow Workshop on Functional Programming},
pages = {195--202},
title = {{The nofib benchmark suite of Haskell programs}},
year = {1992}
}
@article{dfa,
author = {Cooper, Keith D and Harvey, Timothy J and Kennedy, Ken},
title = {{Iterative Data-flow Analysis, Revisited}},
year = {2004}
}
@article{firm,
author = {Braun, Matthias and Zwinkau, Andreas},
pages = {61--68},
title = {{FIRM â€” A Graph-Based Intermediate Representation}},
year = {2011}
}
@article{thorin,
author = {Lei{\ss}a, Roland and Marcel, K and Hack, Sebastian},
isbn = {9781479981618},
title = {{A Graph-Based Higher-Order Intermediate Representation}},
year = {2015}
}
@phdthesis{Verstoep,
author = {Verstoep, Hidde},
isbn = {9781450332972},
keywords = {absence analysis,and sharing information,cardinality analysis,polyvariance,sharing anal-,the generic,two different instantiations of,type-based program analysis,uniqueness typing,usage analysis,ysis},
pages = {139--142},
title = {{Polyvariant Cardinality Analysis for Non-strict Higher-order Functional Languages}}
}
@article{cpr,
author = {Baker-finch, Clem and Jones, Simon Peyton},
doi = {10.1017/S0956796803004751},
number = {March},
pages = {211--245},
title = {{Constructed product result analysis for Haskell}},
volume = {14},
year = {2004}
}
@article{anf,
author = {Sabry, A M R and Felleisen, Matthias},
keywords = {-calculus,continuation-passing style,cps transformations,inverse cps transformations,iocc,v -c-calculus,v -calculus},
title = {{Reasoning about Programs in Continuation-Passing Style}},
year = {1993}
}
@techreport{dmd,
author = {{Peyton Jones}, Simon and Sestoft, Peter and Hughes, John},
title = {{Demand analysis}}
}
@article{ww,
author = {Gill, Andy and Hutton, Graham},
doi = {10.1017/S0956796809007175},
number = {2},
pages = {227--251},
title = {{The worker / wrapper transformation}},
volume = {19},
year = {2009}
}
@phdthesis{callarity,
author = {Breitner, Joachim},
school = {Karlsruhe Institute of Technology},
title = {{Lazy Evaluation: From natural semantics to a machine-checked compiler transformation}},
year = {2016}
}
@phdthesis{warnsbrough,
author = {Wansbrough, Keith},
number = {623},
school = {University of Cambridge},
title = {{Simple polymorphic usage analysis}},
year = {2005}
}
@article{card,
author = {Sergey, Ilya and {Peyton Jones}, Simon},
title = {{Modular, Higher-Order Cardinality Analysis in Theory and Practice}}
}
@incollection{agt,
abstract = {This chapter introduces the class of perfect graphs known as comparability graphs or transitively orientable graphs. An undirected graph G=(V, E) is a comparability graph if there exists an orientation (V, F) of G. The relation F is a strict partial ordering of V whose comparability relation is exactly E, and F is called a transitive orientation of G (or of E). Comparability graphs are also known as transitively orientable graphs and partially orderable graphs. Examples of several comparability graphs are presented. The chapter provides the justification for an algorithm, which assigns a transitive orientation to a comparability graph. A graph is called decomposable if it can be expressed as a nontrivial composition of some of its induced subgraphs; otherwise, it is called indecomposable.},
author = {Golumbic, Martin Charles},
booktitle = {Annals of Discrete Mathematics},
doi = {10.1016/S0167-5060(04)80053-0},
isbn = {9780444515308},
issn = {01675060},
pages = {105--148},
title = {{Comparability graphs}},
volume = {57},
year = {2004}
}
