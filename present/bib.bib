@phdthesis{sestoft,
author = {Sestoft, Peter},
title = {{Analysis and Efficient Implementation of Functional Programs}},
year = {1991}
}
@mastersthesis{verstoepthesis,
abstract = {There are a number of different analyses for functional languages that count in one way or another (e.g., strictness analysis, sharing analysis). There has been a lot of research into each of these analyses individually. The analysis described in this thesis combines a number of these counting analyses into one analysis.},
author = {Verstoep, Hidde},
school = {Utrecht University},
title = {{Counting Analyses}},
year = {2013}
}
@article{hoopl,
 author = {Ramsey, Norman and Dias, Jo\~{a}o and Peyton Jones, Simon},
 title = {Hoopl: A Modular, Reusable Library for Dataflow Analysis and Transformation},
 journal = {SIGPLAN Not.},
 issue_date = {November 2010},
 volume = {45},
 number = {11},
 month = sep,
 year = {2010},
 issn = {0362-1340},
 pages = {121--134},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2088456.1863539},
 doi = {10.1145/2088456.1863539},
 acmid = {1863539},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dataflow},
}
@inproceedings{type,
 author = {Turner, David N. and Wadler, Philip and Mossin, Christian},
 title = {Once Upon a Type},
 booktitle = {Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture},
 series = {FPCA '95},
 year = {1995},
 isbn = {0-89791-719-7},
 location = {La Jolla, California, USA},
 pages = {1--11},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/224164.224168},
 doi = {10.1145/224164.224168},
 acmid = {224168},
 publisher = {ACM},
 address = {New York, NY, USA},
}
@inproceedings{polytype,
 author = {Wansbrough, Keith and Peyton Jones, Simon},
 title = {Once Upon a Polymorphic Type},
 booktitle = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '99},
 year = {1999},
 isbn = {1-58113-095-3},
 location = {San Antonio, Texas, USA},
 pages = {15--28},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/292540.292545},
 doi = {10.1145/292540.292545},
 acmid = {292545},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@inproceedings{verstoep,
 author = {Verstoep, Hidde and Hage, Jurriaan},
 title = {Polyvariant Cardinality Analysis for Non-strict Higher-order Functional Languages: Brief Announcement},
 booktitle = {Proceedings of the 2015 Workshop on Partial Evaluation and Program Manipulation},
 series = {PEPM '15},
 year = {2015},
 isbn = {978-1-4503-3297-2},
 location = {Mumbai, India},
 pages = {139--142},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/2678015.2682536},
 doi = {10.1145/2678015.2682536},
 acmid = {2682536},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {absence analysis, cardinality analysis, polyvariance, sharing analysis, type-based program analysis, uniqueness typing, usage analysis},
} 
@Inbook{projimpl,
author="Kubiak, Ryszard
and Hughes, John
and Launchbury, John",
editor="Heldal, Rogardt
and Holst, Carsten Kehler
and Wadler, Philip",
title="Implementing Projection-based Strictness Analysis",
bookTitle="Functional Programming, Glasgow 1991: Proceedings of the 1991 Glasgow Workshop on Functional Programming, Portree, Isle of Skye, 12--14 August 1991",
year="1992",
publisher="Springer London",
address="London",
pages="207--224",
abstract="Projection-based backwards strictness analysis has been understood for some years. Surprisingly, even though the method is fairly simple and quite general, no reports of its implementation have appeared. This paper describes ideas underlying our prototype implementation of the analysis for a simple programming language. The implementation serves as a case study before applying the method in the Glasgow Haskell compiler.",
isbn="978-1-4471-3196-0",
doi="10.1007/978-1-4471-3196-0_17",
url="https://doi.org/10.1007/978-1-4471-3196-0_17"
}
@phdthesis{projs,
author = {Hinze, Ralph},
pages = {237},
school = {Universit{\"{a}}t Bonn},
title = {{Projection-based strictness analysis - theoretical and practical aspects.}},
year = {1995}
}
@article{sharing,
 author = {Hage, Jurriaan and Holdermans, Stefan and Middelkoop, Arie},
 title = {A Generic Usage Analysis with Subeffect Qualifiers},
 journal = {SIGPLAN Not.},
 issue_date = {September 2007},
 volume = {42},
 number = {9},
 month = oct,
 year = {2007},
 issn = {0362-1340},
 pages = {235--246},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1291220.1291189},
 doi = {10.1145/1291220.1291189},
 acmid = {1291189},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {qualified types, sharing analysis, type and effect systems, uniqueness typing},
} 
@Inbook{updabs,
author="Marlow, Simon",
editor="O'Donnell, John T.
and Hammond, Kevin",
title="Update Avoidance Analysis by Abstract Interpretation",
bookTitle="Functional Programming, Glasgow 1993: Proceedings of the 1993 Glasgow Workshop on Functional Programming, Ayr, Scotland, 5--7 July 1993",
year="1994",
publisher="Springer London",
address="London",
pages="170--184",
abstract="A requirement of lazy evaluation is that the value of any subexpression in the program is calculated no more than once. This is achieved by updating an expression with its value, once computed. The problem is that updating is a costly operation, and experimentation has shown that it is only necessary in about 30{\%} of cases (that is, 70{\%} of expressions represent values that are only ever required once during execution). The aim of the analysis presented in this paper is to discover expressions that do not need to be updated, and thus reduce the execution time of the program. The analysis has been implemented in the Glasgow Haskell Compiler, and results are given.",
isbn="978-1-4471-3236-3",
doi="10.1007/978-1-4471-3236-3_14",
url="https://doi.org/10.1007/978-1-4471-3236-3_14"
}
@article{statethreads,
 author = {Launchbury, John and Peyton Jones, Simon L.},
 title = {Lazy Functional State Threads},
 journal = {SIGPLAN Not.},
 issue_date = {June 1994},
 volume = {29},
 number = {6},
 month = jun,
 year = {1994},
 issn = {0362-1340},
 pages = {24--35},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/773473.178246},
 doi = {10.1145/773473.178246},
 acmid = {178246},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@Inbook{nofib,
author="Partain, Will",
editor="Launchbury, John
and Sansom, Patrick",
title="The nofib Benchmark Suite of Haskell Programs",
bookTitle="Functional Programming, Glasgow 1992: Proceedings of the 1992 Glasgow Workshop on Functional Programming, Ayr, Scotland, 6--8 July 1992",
year="1993",
publisher="Springer London",
address="London",
pages="195--202",
abstract="This position paper describes the need for, make-up of, and ``rules of the game'' for a benchmark suite of Haskell programs. (It does not include results from running the suite.) Those of us working on the Glasgow Haskell compiler hope this suite will encourage sound, quantitative assessment of lazy functional programming systems. This version of this paper reflects the state of play at the initial pre-release of the suite.",
isbn="978-1-4471-3215-8",
doi="10.1007/978-1-4471-3215-8_17",
url="https://doi.org/10.1007/978-1-4471-3215-8_17"
}
@article{dfa,
  title={Iterative dataflow analysis, revisited},
  author={Cooper, Keith D and Harvey, Timothy J and Kennedy, Ken},
  year={2002}
}
@book{firm,
  title={Firm - A graph-based intermediate representation},
  author={Braun, Matthias and Buchwald, Sebastian and Zwinkau, Andreas},
  year={2011},
  publisher={KIT, Fakult{\"a}t f{\"u}r Informatik}
}
@inproceedings{thorin,
 author = {Lei{\ss}a, Roland and K\"{o}ster, Marcel and Hack, Sebastian},
 title = {A Graph-based Higher-order Intermediate Representation},
 booktitle = {Proceedings of the 13th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
 series = {CGO '15},
 year = {2015},
 isbn = {978-1-4799-8161-8},
 location = {San Francisco, California},
 pages = {202--212},
 numpages = {11},
 url = {http://dl.acm.org/citation.cfm?id=2738600.2738626},
 acmid = {2738626},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
} 
@article{cpr,
 author = {Baker-Finch, Clem and Glynn, Kevin and Jones, Simon Peyton},
 title = {Constructed Product Result Analysis for Haskell},
 journal = {J. Funct. Program.},
 issue_date = {March 2004},
 volume = {14},
 number = {2},
 month = mar,
 year = {2004},
 issn = {0956-7968},
 pages = {211--245},
 numpages = {35},
 url = {http://dx.doi.org/10.1017/S0956796803004751},
 doi = {10.1017/S0956796803004751},
 acmid = {967508},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
} 
@article{anf,
 author = {Sabry, Amr and Felleisen, Matthias},
 title = {Reasoning About Programs in Continuation-passing Style.},
 journal = {SIGPLAN Lisp Pointers},
 issue_date = {Jan. 1992},
 volume = {V},
 number = {1},
 month = jan,
 year = {1992},
 issn = {1045-3563},
 pages = {288--298},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/141478.141563},
 doi = {10.1145/141478.141563},
 acmid = {141563},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@other{dmd,
author = {Peyton Jones, Simon and Sestoft, Peter and Hughes, John},
title = {Demand Analysis},
year = {2006},
month = {July},
url = {https://www.microsoft.com/en-us/research/publication/demand-analysis/},
}
@article{ww,
 author = {Gill, Andy and Hutton, Graham},
 title = {The Worker/Wrapper Transformation},
 journal = {J. Funct. Program.},
 issue_date = {March 2009},
 volume = {19},
 number = {2},
 month = mar,
 year = {2009},
 issn = {0956-7968},
 pages = {227--251},
 numpages = {25},
 url = {http://dx.doi.org/10.1017/S0956796809007175},
 doi = {10.1017/S0956796809007175},
 acmid = {1520290},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
} 
@phdthesis{callarity,
author = {Breitner, Joachim},
school = {Karlsruhe Institute of Technology},
title = {{Lazy Evaluation: From natural semantics to a machine-checked compiler transformation}},
year = {2016}
}
@phdthesis{warnsbrough,
author = {Wansbrough, Keith},
school = {University of Cambridge},
title = {{Simple polymorphic usage analysis}},
year = {2005}
}
@article{card,
 author = {Sergey, Ilya and Vytiniotis, Dimitrios and Peyton Jones, Simon},
 title = {Modular, Higher-order Cardinality Analysis in Theory and Practice},
 journal = {SIGPLAN Not.},
 issue_date = {January 2014},
 volume = {49},
 number = {1},
 month = jan,
 year = {2014},
 issn = {0362-1340},
 pages = {335--347},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/2578855.2535861},
 doi = {10.1145/2578855.2535861},
 acmid = {2535861},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {cardinality analysis, compilers, functional programming languages, haskell, lazy evaluation, operational semantics, program optimisation, static analysis, thunks, types and effects},
} 
@incollection{agt,
abstract = {This chapter introduces the class of perfect graphs known as comparability graphs or transitively orientable graphs. An undirected graph G=(V, E) is a comparability graph if there exists an orientation (V, F) of G. The relation F is a strict partial ordering of V whose comparability relation is exactly E, and F is called a transitive orientation of G (or of E). Comparability graphs are also known as transitively orientable graphs and partially orderable graphs. Examples of several comparability graphs are presented. The chapter provides the justification for an algorithm, which assigns a transitive orientation to a comparability graph. A graph is called decomposable if it can be expressed as a nontrivial composition of some of its induced subgraphs; otherwise, it is called indecomposable.},
author = {Golumbic, Martin Charles},
booktitle = {Annals of Discrete Mathematics},
doi = {10.1016/S0167-5060(04)80053-0},
isbn = {9780444515308},
issn = {01675060},
pages = {105--148},
title = {{Comparability graphs}},
volume = {57},
year = {2004}
}
@inbook{wadlerproj,
  author="Wadler, Philip
    and Hughes, R. J. M.",
  editor="Kahn, Gilles",
  title="Projections for strictness analysis",
  bookTitle="Functional Programming Languages and Computer Architecture: Portland, Oregon, USA, September 14--16, 1987 Proceedings",
  year="1987",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="385--407",
  abstract="Contexts have been proposed as a means of performing strictness analysis on non-flat domains. Roughly speaking, a context describes how much a sub-expression will be evaluated by the surrounding program. This paper shows how contexts can be represented using the notion of projection from domain theory. This is clearer than the previous explanation of contexts in terms of continuations. In addition, this paper describes finite domains of contexts over the non-flat list domain. This
    means that recursive context equations can be solved using standard fixpoint techniques, instead of the algebraic manipulation previously used.",
  isbn="978-3-540-47879-9",
  doi="10.1007/3-540-18317-5_21",
  url="https://doi.org/10.1007/3-540-18317-5_21"
}
